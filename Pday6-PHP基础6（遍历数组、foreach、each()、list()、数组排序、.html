<html>
<head>
  <title>Pday6-PHP基础6（遍历数组、foreach、each()、list()、数组排序、函数调用）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303788 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="585"/>
<h1>Pday6-PHP基础6（遍历数组、foreach、each()、list()、数组排序、函数调用）</h1>

<div>
<span><div><span style="font-size: 19px;"><b>Pday6-PHP基础6（遍历数组、foreach、each()、list()、数组排序、函数调用）</b></span></div><div><span style="font-size: 16px;"><b>一、遍历数组</b></span> ：对一个数组的内容完全不知道的情况下，通过循环结构去依次获取数组里面的每一个元素</div><div>    <b> 1、数组元素指针</b>的理解：每一个数组都有一个唯一数组指针；</div><div>          数组初始化，指针总是指向第一个元素。</div><div>          数组指针，总是指向一个数组元素。也可以指向数组末端或上端未知(非法区域)，这时则返回FALSE，foreach循环结束。</div><div>     <b>2、数组指针的函数：current()、key()、next()、prev()、reset()、end()</b></div><div style="margin-left:40px;">  <b>  1.不移动指针：current()</b>：获取当前指针处元素的<b>值</b>，<b>2.key()</b>：<b>获取</b>指针处元素<b>下标</b>。   </div><div style="margin-left:40px;"><b>    3.next()</b>：指针<b>下移一</b>行，返回下一个数组元素的值<b>；4.prev()</b>：将指针<b>上移一</b>步，返回上一个数组元素的值。</div><div style="margin-left:40px;">    <b>5.reset()：</b>将指针移到<b>第一</b>个合法位置元素上，返回第一个数组元素的值；<b>6.end()：</b>指针移到数组<b>最后</b>一个元素，返回最后一元素的值。</div><div style="margin-left:40px;">    注意1.上移和下移指针是相对于当前位置为参考，但是指针一旦处于非法位置，就没有参照物了，所以指针无法上下移，返回false。</div><div>              注意2.重置指针reset()和最后位end()，不需要参考当前位置，直接可以定位。</div><div>              注意3.当指针处于非法位置，其值为false，下标为null。例：</div><div style="margin-left:80px;">        <i>$arr=array('哈士奇','萨摩耶','阿拉斯加');</i></div><div style="margin-left:80px;"><i>        for(;current($arr);<b>next($arr)</b>){     //用for循环结合指针函数遍历数组</i></div><div style="margin-left:80px;"><i>            echo '数组当前下标为',<b>key($arr)</b>,'&lt;br/&gt;';//数组当前下标为0……</i></div><div style="margin-left:80px;"><i>            echo '数组当前值为',<b>current($arr),</b>'&lt;br/&gt;';//数组当前值为哈士奇……</i></div><div style="margin-left:80px;"><i>        }</i></div><div><span style="font-size: 16px;"><b>二、Foreach循环:1foreach先下标后移再操作，2写时复制后操作的是拷贝值数组，对其操作不影响原数组。</b></span></div><div>    <b>1、语法结构</b>：语法一：foreach($arr as $value){……};语法二：foreach($arr as $key=&gt;$value){……}//既遍历数组下标也遍历值</div><div style="margin-left:40px;">    注意1.foreach一般情况指针遍历完数组后，指针处于一个非法位置。</div><div style="margin-left:40px;">    注意2.foreach遍历数组之前，会先对指针做一个初始化操作（reset）。</div><div style="margin-left:40px;">    注意3.foreach遍历数组，实际遍历和操作的是数组的拷贝值，修改原数组，拷贝后的数组不会修改。</div><div style="margin-left:40px;">    注意4.同理，修改$value的值，原数组也不会发生变化。</div><div style="margin-left:40px;">    注意5.如果想在修改$value的同时修改原数组的值，那么在foreach的小括号内，$value前加一个&amp;取地址。</div><div>        例：foreach($arr as $key=&gt;&amp;$value){     $value='金毛'； echo $value,'&lt;br/&gt;';     }//金毛 金毛 金毛</div><div>         var_dump($arr);//结果array(3) { [0]=&gt; string(6) &quot;金毛&quot; [1]=&gt; string(6) &quot;金毛&quot; [2]=&gt; &amp;string(6) &quot;金毛&quot; }</div><div style="margin-left:40px;">  <b>  关于数组变量复制时指针的问题</b></div><div style="margin-left:40px;">    当一个变量复制另一个变量后，移动其中一个变量的指针，另一个不会发生变化。</div><div style="margin-left:40px;">    当一个变量复制另一个变量时，指针也跟着一起复制。</div><div style="margin-left:40px;">    当一个变量处于非法位置时，复制给另一个变量，先输出谁，谁就被初始化操作了，另一个还处于非法位。</div><div style="margin-left:40px;">    foreach遍历数组后，指针处于一个不确定的情况，建议在foreach之后还要对指针操作的话，先对指针做一个初始化操作。</div><div style="margin-left:40px;"><i>$arr=array( array(10,11,12),array(20,21),array(30),    );//用foreach遍历二维数组</i></div><div style="margin-left:40px;"><i>        $sum=0;</i></div><div style="margin-left:40px;"><i>        foreach($arr as $arr2){//foreach遍历二维数组</i></div><div style="margin-left:40px;"><i>                 foreach($arr2 as $value){</i></div><div style="margin-left:40px;"><i>                                    $sum+=$value;    }</i></div><div style="margin-left:40px;"><i>        }  echo '平均值:'.$sum;//平均值：104</i></div><div>以下代码功能也完全相同：</div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">&lt;?php</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">$arr = array(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;);</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">reset($arr);</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">while (list($key, $value) = each($arr)) {</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    echo &quot;Key: $key; Value: $value&lt;br /&gt;\n&quot;;</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">}</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);"><br/></span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">foreach ($arr as $key =&gt; $value) {</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    echo &quot;Key: $key; Value: $value&lt;br /&gt;\n&quot;;</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">}</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">?&gt;</span></span></span></div></div><div><span style="font-size: 16px;"><b>三、数组操作函数</b></span></div><div><b><span style="font-size: 16px;">     </span>  1.each()</b>：<b>返回</b>数组中当前的<b>键／值对</b>并将数组指针向下移动一步</div><div>         语法：array each ( array &amp;$array )，作用：相当current()+key()+next()</div><div style="margin-left:40px;">    既可以获取当前指针指向的元素下标和值，也可以让指针自动下移一位</div><div>              each()获取数组元素的信息，<b>是4个元素的数组</b>，分别是关联数组下的下标和值key=&gt;$key value=&gt;$value和</div><div>                             索引数组下的下标和值0=&gt;$key 1=&gt;$value     //0、key是键，1、value是值</div><div>         如果内部指针越过了数组的末端，则 each() 返回 FALSE。</div><div style="margin-left:80px;"><i>while($arr2=each($arr)){    echo '元素下标为:'，$arr2['key'],'&lt;br&gt;'</i></div><div><i>                                                             echo '元素的值为:'，$arr2[1],'&lt;hr&gt;'}    //结果循环遍历数组中元素</i></div><div>         <b>2、list()：把数组中的值赋给一些变量</b></div><div>         语法：array list ( mixed $varname [, mixed $... ] )</div><div>               作用：将数组里面某些元素的值赋值给一些变量。要求数组元素的下标必须从0开始依次递增。</div><div>         如：list($a,$b)=$arr;$a就是获取$arr中下标为0的值，$b就是获取$arr中下标为1的值。依次类推</div><div><i>                    while(list($key,$value,)=each($arr)){     echo '元素下标为: ',$key,'&lt;br&gt;';</i></div><div><i>                                                                               echo '元素的值为: ',$value,'&lt;hr&gt;';} //结果循环遍历数组中元素</i></div><div><i>               再例：1. $arr=array(1=&gt;'可乐','a'=&gt;'雪碧','b'=&gt;'芬达',0=&gt;'七喜',2=&gt;'健力宝',);       //注意取的下标</i></div><div><i>                       </i> <i>2. list($a,$b,$c)=$arr;</i>      <i>3. echo $a,' ',$b,' ',$c;    //结果</i><b>七喜 可乐 健力宝</b></div><div><i><br/></i></div><div><span style="font-size: 16px;"><b>四、数组排序</b></span></div><div style="margin-left:40px;">    sort()：对数组元素的值升序排列，不保留索引关系。(下标发生改变从0升序)</div><div style="margin-left:40px;">    rsort()：对数组元素的值降序排列，不保留索引关系。</div><div style="margin-left:40px;">    asort()：对数组元素的值升序排列，保留索引关系。</div><div style="margin-left:40px;">    arsort()：对数组元素的值降序排列，保留索引关系。</div><div style="margin-left:40px;">    ksort()：数组按键名(下标)升序排列，保留索引关系。</div><div style="margin-left:40px;">    krsort()：数组按键名降序排列，保留索引关系</div><div style="margin-left:40px;">    natsort()：sort进行包含字符串的数字排序，那么其排序的原则是按照字符串大小一个一个字符进行排序，有些场景不使用。</div><div>                       因此，natsort就是将整个字符串当成一个整体，然后进行排序。natsort保留原来数组的下标。</div><div>              usort():用户可以自定义排序，多用于二维数组</div><div>                       语法：usort（数组名，函数），有两参数，排序的原则是两两进行比较排序。如果想让哪个往<b>后排</b>，返回一<b>大于0</b>的整数。</div><div>        想让某元素<b>前排</b>，返回<b>小于0</b>的整数，元素位置保持<b>不变</b>的话，那么直接返回一个<b>0</b>。返回的结果不保留原来的下标。</div><div style="margin-left:80px;"><i>        例：usort($arr,function($num1,$num2){</i></div><div style="margin-left:80px;"><i>            if($num1['age']&gt;$num2['age']){return 1;</i></div><div style="margin-left:80px;"><i>            }elseif($num1['age']&lt;$num2['age']){return -1;</i></div><div style="margin-left:80px;"><i>            }else{return 0;}    });</i></div><div>    <b>注意</b>：所有的排序函数，都是在原来的数组基础上进行排序的，所以只要使用，原数组的排序和关联就改变。</div><div><br/></div><div><span style="font-size: 16px;"><b>五、函数</b></span>：将一串功能性的代码封装在一个函数内，然后可以多次重复调用。优点：1方便，2适合结构化编程</div><div>         <b>1、函数定义格式 </b>   <i>function funcName([形参1][,形参2][,形参3]……){//函数名称funcName必须唯一</i></div><div style="margin-left:120px;"><i>                函数的功能代码；</i></div><div style="margin-left:120px;"><i>                [return 参数]    //将函数执行结果返回函数调用者，return语句一旦执行，其后的代码不再执行</i></div><div style="margin-left:120px;"><i>                        一函数体可有多return，一般在条件判断有多个return，根据不同结果返回不同值。</i></div><div style="margin-left:120px;"><i>        }</i></div><div><b>           函数分为函数声明和函数调用两部分，声明可以放在调用后，因为声明函数是在代码的解析阶段开辟空间，调用函数是在代码执行阶段。</b></div><div><b>         2、函数调用：</b></div><div>                   了解栈内存，堆内存，代码区，静态区</div><div><b>         3、函数参数</b></div><div style="margin-left:40px;">        形参(形式参数)：主要用来获取调用函数者传递过来的数据。是一个临时容器。</div><div style="margin-left:40px;">        实参(实际数据)：是真正的数据。实参可以是具体的值，也可以是变量。</div><div style="margin-left:40px;">   提示：形参不能是具体的值，只能是变量。形参&gt;=实参的参数个数通常要对等。</div><div style="margin-left:40px;">        当形参个数大于实参个数，系统报错但仍会执行；当形参个数小于实参个数，系统照常执行不报错</div><div style="margin-left:40px;">        例：fn(10,20,30,40,50,60,70,80);//结果100---相当于后面4个实参没有传递</div><div style="margin-left:40px;"><b>4、函数参数传递</b></div><div style="margin-left:40px;">    ①值传递---又称”拷贝传值”。</div><div style="margin-left:40px;">        如果在函数内修改了变量的值，函数外变量的值，不会变。</div><div style="margin-left:40px;">    ②引用传递---又称为”引用传地址”。</div><div style="margin-left:40px;">        使用”&amp;”，可以将其它变量变成”引用传递”。默认情况下，对象和资源是引用传递。</div><div style="margin-left:40px;">        通常引用传递用在形参上，function showInfo(&amp;$name,&amp;$age){……}</div><div style="margin-left:40px;">    ③默认参数---PHP支持默认参数传递。可以减少出错率。</div><div style="margin-left:40px;">        如果实参个数少于形参时，将用默认参数来代替实参。</div><div style="margin-left:40px;">        1提示：默认参数的值几乎所有类型都可，但不能是函数调用、资源、对象。如$action=&quot;round(12.987)&quot;会报错!</div><div style="margin-left:80px;">        function showInfo($name,$action=&quot;打太极&quot;){ echo &quot;{$name}正在{$action}!&quot;;}</div><div style="margin-left:80px;">        showInfo(&quot;老马&quot;);//老马正在打太极！    //2。注意：默认参数只能放在非默认参数的右边。</div><div style="margin-left:80px;">        showInfo(&quot;李四&quot;,&quot;打游戏&quot;);//李四正在打游戏！</div><div style="margin-left:40px;">        3.默认参数不能是一个变量，但是可以是一个常量，但要在函数调用之前定义该常量。</div><div><b>拓展：写时复制 COW---copy on write</b></div><div style="margin-left:40px;">当一个变量复制另一个变量的时候，其实并没有直接去开辟一个空间，只有<b>当其中一个</b>变量进行写操作的时候，另一个变量才会去开辟空间。</div><div>例：模拟计算机内存去演示写时复制</div><div>         memory_get_usage():获取当前代码占用的计算机内存。</div><div>         array_fill(startnum,num,value):创建一个数组元素，startnum代表开始起始下标，num代表数组中一共有多少个元素，value给所有元素统一赋值。</div><div align="left" style="margin-left:0mm; margin-right:0mm; text-indent:10mm; margin-top:0.00mm; margin-bottom:0.00mm;min-height: 113pt;"><div><i>        echo memory_get_usage(),'&lt;br&gt;';//225152</i></div><div><i>        $arr=array_fill(1,100000,1);             //（</i>第一个元素的下标 ,元素个数100000，value给所有元素赋值 1<i>）</i></div><div><i>        echo memory_get_usage(),'&lt;br&gt;';//9272416</i></div><div><i>        $arr2=$arr;</i></div><div><i>        echo memory_get_usage(),'&lt;br&gt;';//9272128 ---空间没有明显变化</i></div><div><i>        $arr[]=2;</i></div><div><i>        echo memory_get_usage(),'&lt;br&gt;';//18320976--空间明显变化，这时$arr才去开辟了一个空间。</i></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div><b><span style="font-size: 16px;">//foreach举例：</span></b></div><div>    $arr=array('天','地','玄','黄');</div><div>    foreach($arr as $key=&gt;$value){</div><div>    }</div><div>    var_dump(current($arr));//指针处于非法位置</div><div><br/></div><div>    $arr=array('天','地','玄','黄');</div><div>    foreach($arr as $key=&gt;$value){</div><div>       $arr[2]='王';</div><div>    }</div><div>    var_dump(current($arr));//指向地，？先拷贝一份下标下移再操作，原数组指针仍然停在拷贝前</div><div>    echo $value;//黄，拷贝值下标已经移到黄</div><div><br/></div><div>    $arr=array('天','地','玄','黄');</div><div>    foreach($arr as $key=&gt;$value){</div><div>       if($key==1){</div><div>           $arr[2]='王';</div><div>       }</div><div>    }</div><div>    var_dump(current($arr));//指针指向王</div><div><br/></div><div>    $arr=array('天','地','玄','黄');</div><div>    foreach($arr as $key=&gt;$value){</div><div>       if($key==2){</div><div>           $arr[2]='王';</div><div>       }</div><div>    }</div><div>    var_dump(current($arr));//指针指向黄，先下标后移再操作</div><div><br/></div><div>    $arr=array('天','地','玄','黄');</div><div>    foreach($arr as $key=&gt;$value){</div><div>       if($key==3){</div><div>           $arr[2]='王';</div><div>       }</div><div>    }</div><div>    var_dump(current($arr));//指针指向天，？谁先写操作谁初始化，另一非法区域</div><div><br/></div><div>    $arr=array('天','地','玄','黄');</div><div>    foreach($arr as $key=&gt;$value){</div><div>       if($key==4){</div><div>           $arr[2]='王';</div><div>       }</div><div>    }</div><div>    var_dump(current($arr));//指针指向false，非法区域</div></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 