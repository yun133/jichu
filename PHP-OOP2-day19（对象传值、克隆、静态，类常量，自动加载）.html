<html>
<head>
  <title>PHP-OOP2-day19（对象传值、克隆、静态，类常量，自动加载）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303788 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1587"/>
<h1>PHP-OOP2-day19（对象传值、克隆、静态，类常量，自动加载）</h1>

<div>
<span><div><b><span style="font-size: 21px;">PHP-OOP2-day19（<span style="font-size: 16px;">对象传值、克隆、静态，类常量，自动加载</span>）</span></b></div><div align="justify" style="min-height: 13pt;"><div><span style="font-size: 19px;"><b><font color="#010101">一、对象的传值</font></b></span></div></div><div style="margin-left:40px;">1.为什么对象之间，不管使用值传递还是引用传递，<b>效果都是引用传递的效果？</b></div><div style="margin-left:80px;">本质：对象的变量名并不是直接引用对象的内存空间，而<b>是引用对象的内部编号</b>。而对象的值传递或者引用传递，</div><div style="margin-left:80px;">其实复制的都是这个编号，所以效果都是引用传递的效果。</div><div style="margin-left:40px;"><div align="justify" style="min-height: 13pt;"><div><span style="font-size: 16px;"><b><font color="#010101" face="宋体">2.</font></b></span><font color="#010101" size="2"><span style="font-family: 宋体;"><span style="font-size:10pt">对象间的复制，无法开辟一个新的对象空间，有时候，也称之为</span><span style="font-size:10pt; background:#ffff00">“浅复制”</span></span><span style="font-size:10pt"><span style="font-family: 宋体;">！例</span><b>$stu2=$stu1;</b></span></font></div></div></div><div align="justify" style="min-height: 13pt;margin-left:40px;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">3.那么，<span style="font-size: 16px;"><b>如何</b>使用一个已有的对象，得到一个全新的对象呢</span>（单独开辟新的内存空间）--</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#00ff00">需要使用对象的克隆！</span></font></div></div><div><b><span style="font-size: 19px;">二、对象的克隆(生成对象的两种方法之二)</span></b></div><div align="justify" style="min-height: 13pt;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">     1.所谓的<span style="font-size: 16px;">克隆</span>，不是通过类的实例化得到一个新对象，而是<b>通过一个已有的对象得到一个新对象</b>！</span></font></div></div><div style="margin-left:40px;"><span style="font-size: 16px;"><b><font color="#010101" face="黑体"><b>2.语法形式</b></font></b></span><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>新对象</b></span></font> <font color="#FF0000" face="Calibri" size="2"><span style="font-size:10pt"><b>=  clone</b></span></font> <font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>已有对象------例：$stu2 = clone $stu1;</b></span></font></div><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">     新旧对象之间，具有<b>相同属性名和值</b>，但是对象的<b>内存空间不同</b>（内部编号不同）</span></font></div><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">     注意：克隆不是实例化，所以不需要执行构造方法！</span></font></div></div><div align="justify" style="min-height: 13pt;"><div><font color="#002060" face="宋体" size="2"><span style="font-size:10pt"><b>     <span style="font-size: 16px;">3.使用<span style="color: rgb(255, 0, 0);">instanceof</span>运算符</span>判断某个对象是否是由某个类实例化而来的！</b></span></font></div><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>形式为：</b></span></font><font color="#002060" face="宋体" size="2"><span style="font-size:10pt"><b>对象变量 </b></span></font><font color="#FF0000" face="Calibri" size="2"><span style="font-size:10pt"><b>instanceof  </b></span></font><font color="#002060" face="宋体" size="2"><span style="font-size:10pt"><b>类名---结果：</b></span></font><font color="#002060" face="宋体" size="2"><span style="font-size:10pt"><b>返回一个布尔值！例</b></span></font>var_dump($stu2 instanceof Student); //bool(true)</div></div></div><div>          4.<span style="font-size: 19px;"><b><font color="#010101" face="Arial"><b>__clone()</b></font><font color="#010101" face="黑体">方法</font></b></span><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">也是属于魔术方法！</span></font></div><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><div align="left" style="min-height: 18pt;"><div>触发情况：__当一个对象被克隆的时候自动调用该魔术方法！功能：对克隆出来的新对象进行相关的初始化！</div></div></div></div><div><b><span style="font-size: 19px;">三、<font color="#010101" face="Calibri">MySQLDB</font><font color="#010101" face="宋体">类初步</font></span></b></div><div align="justify" style="min-height: 13pt;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#00ff00">     一般类文件的命名方式为：</span></font><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>类名</b></span></font><font color="#FF0000" face="Calibri" size="2"><span style="font-size:10pt"><b>.class.php--------例：MySQLDB.class.php</b></span></font></div></div><div style="margin-left:40px;">1.设置属性，<font color="#010101" face="宋体" size="2"><span style="font-size:10pt">实例化的时候对属性进行初始化</span></font></div><div style="margin-left:40px;">2.<font color="#010101" face="宋体" size="2"><span style="font-size:10pt">完成对数据库的连接三步曲（连接数据库，选择默认数据库，设置默认字符集）（构造方法）</span></font></div><div style="margin-left:40px;">3.<font color="#010101" face="宋体" size="2"><span style="font-size:10pt">销毁该对象，释放对象所占用的数据库连接资源（析构方法）</span></font></div><div><b><span style="font-size: 19px;">四、<font color="#010101">静态成员</font></span></b></div><div>（1）静态属性   </div><div align="left" style="min-height: 10pt;"><div style="margin-left:40px;"><font color="#010101" face="����" size="1"><span style="font-size:9pt">1、用来定义属于类的属性。静态属性属于类，所以只占一块内存空间，每个对象都可以引用这块内存空间。</span></font></div><div style="margin-left:40px;"><font color="#010101" face="����" size="1"><span style="font-size:9pt">      静态属性的值对于各实例是一样的，如果改变，则都改变。通常用来存储属于该类的属性。</span></font></div><div style="margin-left:40px;"><span style="font-size: 9pt;"><span style="font-family: ����;"><span style="color: rgb(1, 1, 1);">2、</span></span></span><font color="#010101" face="����" size="1"><span style="font-size:9pt">声明：<b>访问控制修饰符  static  属性名-----例：</b></span></font> <font face="΢���ź�" size="1"><span style="font-size:9pt">public static $total = 0;</span></font><font face="΢���ź�" size="1"><span style="font-size:9pt">//声明一个$total的静态属性</span></font></div><div style="margin-left:40px;"><span style="font-size: 9pt;"><span style="font-family: ����;"><span style="color: rgb(1, 1, 1);">3、</span></span></span><font color="#010101" face="����" size="1"><span style="font-size:9pt">访问：静态属性属于类，所以应该用类名来调用。也可以使用实例来调用</span></font></div><div align="left" style="min-height: 10pt;"><div style="margin-left:80px;"><font color="#010101" face="����" size="1"><span style="font-size:9pt">1.在类外访问</span></font></div><div style="margin-left:80px;"><div align="left" style="min-height: 10pt;"><div style="margin-left:40px;"><font color="#010101">使用类名来访问</font><font color="#FF0000"><b>类名</b></font><font color="#FF0000"><b>::</b></font><b><span style="color: rgb(255, 0, 0);">属性名---例：echo Student::$stu_num;</span>//注意这有$</b></div><div style="margin-left:40px;"><font color="#010101" face="����" size="1"><span style="font-size:9pt">通过实例来访问</span></font><font color="#FF0000"><b>例：</b></font><font face="΢���ź�" size="1"><span style="font-size:9pt">$wangwang = new Dog;     </span></font><font face="΢���ź�" size="1"><span style="font-size:9pt">echo $wangwang::$averageLife;</span></font></div></div></div></div><div align="left" style="min-height: 10pt;"><div style="margin-left:80px;"><font color="#010101" face="����" size="1"><span style="font-size:9pt">2.在类内访问</span></font></div><div style="margin-left:120px;"><font color="#010101">使用类名来访问</font><font color="#FF0000"><b>类名</b></font><font color="#FF0000"><b>::</b></font><font color="#FF0000"><b>属性名---例：echo Student::$stu_num;</b></font></div><div style="margin-left:120px;"><font color="#010101" face="����" size="1"><span style="font-size:9pt">通过self关键字调用</span></font><font color="#FF0000"><b>例：echo self::$student;//注意self类外不能使用</b></font></div></div></div><div>（2）静态方法：<font color="#010101" face="宋体" size="2"><span style="font-size:10pt">所有对象所共享的方法！</span></font></div><div align="left" style="min-height: 10pt;"><div style="margin-left:40px;"><font color="#010101" face="����" size="1"><span style="font-size:9pt">1、声明：访问控制修饰符 static 方法名</span></font></div><div style="margin-left:40px;"><font color="#010101" face="����" size="1"><span style="font-size:9pt">2、</span></font><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>访问：</b></span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">类名：：方法名</span></font></div><div align="left" style="min-height: 10pt;"><div style="margin-left:40px;"><font color="#010101" face="����" size="1"><span style="font-size:9pt">     静态方法的访问和静态属性的访问方式相同。</span></font><font color="#010101" face="����" size="1"><span style="font-size:9pt">在类外、</span></font><font color="#010101" face="����" size="1"><span style="font-size:9pt">类内访问<span style="color: rgb(255, 0, 0);">同</span>静态属性访问。</span></font></div></div></div><div align="left" style="min-height: 10pt;"><div><font color="#010101" face="����" size="1"><span style="font-size:9pt">          3、静态方法和非静态方法的区别</span></font><font color="#010101" face="����" size="1"><span style="font-size:9pt"> </span></font></div><div align="left" style="min-height: 10pt;"><div align="left" style="min-height: 10pt;"><div align="justify" style="min-height: 13pt;"><div style="margin-left:80px;"><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>静态方法：</b></span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">指所有的对象共享的方法</span></font></div></div><div align="justify" style="min-height: 13pt;margin-left:40px;"><div style="margin-left:40px;"><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>非静态方法：</b></span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">是指各个对象“独自”占用的方法（尽管也只有一份）</span></font></div></div><div style="margin-left:40px;"><div align="justify" style="min-height: 14pt;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">无论采用什么方式调用静态方法，都<b><span style="color: rgb(255, 0, 0);">不可以使用</span></b></span></font><b><font face="Calibri" size="2"><span style="font-size:10pt; background:#ffff00"><span style="color: rgb(255, 0, 0);">$this!</span>建议用self</span></font></b></div></div></div></div></div></div><div style="margin-left:40px;"><div align="justify" style="min-height: 13pt;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">无论是静态方法，还是非静态方法，类和对象都可以调用！</span></font><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>但是，我们以后编程的标准只有一个：</b></span></font></div><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">那就是类调用静态成员！对象调用非静态成员！切记切记！！！</span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">    class Student{</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">        public static $stu_age;</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">        public function set_age($age){</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">            if (is_int($age)&amp;&amp;$age&gt;=0 &amp;&amp;$age&lt;=150) {</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">                self::$stu_age=$age;//<b>这里设置静态变量时不能用$this,切记</b></span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">            } else {</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">                echo &quot;非法的年龄信息&quot;;</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">                return false;</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">            }</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">        }</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">    }</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">    $stu=new Student;</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">    $stu-&gt;set_age(20);//调用类中公开的接口</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">    echo $stu::$stu_age;     //10,调用并获取静态变量</span></span></div><div><span style="font-size: 12px;"><span style="color: rgb(51, 51, 51);">    var_dump($stu);//object(Student)#1 (0) { }</span></span></div></div></div></div><div><span style="font-size: 19px;"><b>五、类常量</b></span></div><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">就是指在一个类中定义的常量，和普通的常量没有什么本质的区别，只是类常量需要先找到类才能访问常量！</span></font></div><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><span style="font-size:10pt"><font color="#010101" size="2">声明语法：</font><font color="#FF0000"><b>const</b></font> <font color="#FF0000"><b>常量名</b></font> <font color="#FF0000"><b>=</b></font> <font color="#FF0000"><b>常量值</b></font><font color="#FF0000"><b>;例const SCHOOL=&quot;whereit&quot;;</b></font></span></div><div style="margin-left:40px;">访问:<font color="#FF0000" size="2"><span style="font-size:10pt"><b>类名</b></span></font><font color="#FF0000" size="2"><span style="font-size:10pt"><b>::</b></span></font><font size="2"><span style="font-size:10pt"><b><span style="color: rgb(255, 0, 0);">常量名-----</span>例：echo Student::SCHOOL;</b></span></font><font size="2"><span style="font-size:10pt"><b>在一个类的内部，类名也可以使用</b></span></font><font size="2"><span style="font-size:10pt"><b>self</b></span></font><font size="2"><span style="font-size:10pt"><b>来代替！</b></span></font></div></div></div><div align="justify" style="font-weight: bold;"><font color="#010101" face="黑体"><b>注意：类中所有的成员</b></font></div><div align="justify" style="min-height: 14pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">一共有</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt; background:#ffff00">5</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">种：</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">非静态属性，</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">非静态方法，静态</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">方法，</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">静态属性，</span></font> <font color="#010101" face="宋体" size="2"><span style="font-size:10pt">类常量，</span></font></div><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">只有非静态属性保存在对象空间里面，其他都在类的用户代码区</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">和</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">类空间</span></font> <font color="#010101" face="宋体" size="2"><span style="font-size:10pt">。</span></font></div></div></div><div><b><span style="font-size: 19px;">六、</span><font color="#010101" face="黑体" size="4"><span style="font-size:16pt"><b>手动加载类文件include './Student.class.php';</b></span></font></b></div><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">在实际的项目中，如果一个类在多个脚本文件都需要使用的话，可以将这个类</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">文件名字为：</span></font><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>类名</b></span></font><font color="#FF0000" face="Calibri" size="2"><span style="font-size:10pt"><b>.class.php，</b></span></font></div><div style="margin-left:40px;"><font color="#FF0000" face="Calibri" size="2"><span style="font-size:10pt"><b>并</b></span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">单独的放到一个文件内，当需要的时候，将文件加载进来即可！</span></font></div><div align="left" style="min-height: 7pt;"><div style="margin-left:40px;"><font color="#010101">方法：直接使用include_once() 将所需的类文件包含进来，或</font><font color="#010101">将所有的类文件导入一个文件里面，然后需要的时候将这个文件导入即可。</font></div></div></div><div align="justify" style="font-weight: bold;"><span style="font-size: 19px;"><font color="#010101" face="黑体"><b>七、类文件的自动加载</b></font></span></div><div align="justify"><span style="color: rgb(0, 0, 0); font-family: tahoma, arial, 宋体; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial; display: inline !important; float: none;">php加载文件方式：</span><br style="color: rgb(0, 0, 0); font-family: tahoma, arial, 宋体; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial;"/><span style="color: rgb(0, 0, 0); font-family: tahoma, arial, 宋体; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial; display: inline !important; float: none;">1、include,include_once,requice,requice_one常规加载</span><br style="color: rgb(0, 0, 0); font-family: tahoma, arial, 宋体; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial;"/><span style="color: rgb(0, 0, 0); font-family: tahoma, arial, 宋体; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial; display: inline !important; float: none;">2、__autoload()</span></div><div><span style="color: rgb(0, 0, 0); font-family: tahoma, arial, 宋体; font-size: 14px; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); text-decoration-style: initial; text-decoration-color: initial; display: inline !important; float: none;">3、spl_autoload_register()</span></div><div align="left" style="min-height: 12pt;"><div style="margin-left:40px;"><font color="#010101" face="����">函数名：__autoload()</font></div></div><div align="left" style="min-height: 12pt;"><div style="margin-left:40px;"><font color="#010101" face="����">触发情况：当php找不到类文件的时候//<span style="color: rgb(255, 0, 0);">注意触发条件，如果本页面内有该类名，无法加载</span></font></div></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    function __autoload($class_name){</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        if (is_file(&quot;./$class_name.class.php&quot;)) {</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            include_once(&quot;./$class_name.class.php&quot;);</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        }else{</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            die(&quot;./$class_name.class.php不存在&quot;);</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        }</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    }</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">     $stu=new Studet; //本页无Student类，则会自动去Student.class.php中找Student类。</span></span></div></div><div align="justify" style="min-height: 13pt;"><div align="left" style="min-height: 12pt;"><div style="margin-left:40px;"><font color="#010101" face="����">为何要使用自定义的类文件自动加载函数？</font></div><div align="left" style="min-height: 12pt;"><div style="margin-left:40px;"><font color="#010101" face="����">因为随着项目的扩展，可能后期会出现多个自动加载函数，这时候就出现了函数的重名问题，因此我们要自己<b>注册</b>自动加载函数</font></div></div></div><div><b><span style="font-size: 19px;"><font color="#010101" face="宋体">八-9.1注册其他的自动加载函数</font></span></b></div><div style="margin-left:40px;"><span style="font-family: 宋体;"><span style="color: rgb(1, 1, 1);">实现步骤：</span></span><b><font color="#010101" face="黑体"><b>第一步：定义一个可以加载类文件的普通函数</b></font></b></div></div><div align="justify" style="min-height: 13pt;"><div align="left" style="min-height: 12pt;"><div style="margin-left:40px;"><font color="#010101" face="����">     第二步：使用spl_autoload_register(函数名)来实现注册</font><font color="#FF0000" face="Calibri"><b>spl_autoload_register(‘</b></font><font color="#FF0000" face="宋体"><b>函数名</b></font><font color="#FF0000" face="Calibri"><b>’)；</b></font></div><div style="margin-left:40px;"><b><span style="font-family: Calibri;"><span style="color: rgb(255, 0, 0);">注意：</span></span></b></div><div align="left" style="min-height: 12pt;"><div style="margin-left:40px;"><font color="#010101" face="����">1.注册一定要发生在需要某个类之前</font></div><div style="margin-left:40px;"><span style="font-family: ����;"><span style="color: rgb(1, 1, 1);">2.</span></span><font color="#010101" face="����">可以注册多个，在需要的类文件载入成功之前，系统会依次调用</font></div><div style="margin-left:40px;"><span style="font-family: ����;"><span style="color: rgb(1, 1, 1);">3.</span></span><font color="#010101" face="����">一旦注册成功，系统默认的__autoload就会失效，如果想继续使用，就需要像注册其他普通函数一样重新注册</font></div></div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, 'Courier New', monospace; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="color: rgb(51, 51, 51);">    function f1($class_name){</span></div><div><span style="color: rgb(51, 51, 51);">        if (is_file(&quot;./$class_name.class.php&quot;)) {</span></div><div><span style="color: rgb(51, 51, 51);">            include_once(&quot;./$class_name.class.php&quot;);</span></div><div><span style="color: rgb(51, 51, 51);">        }else{</span></div><div><span style="color: rgb(51, 51, 51);">            die(&quot;./$class_name.class.php不存在&quot;);</span></div><div><span style="color: rgb(51, 51, 51);">        }</span></div><div><span style="color: rgb(51, 51, 51);">    }</span></div><div><span style="color: rgb(51, 51, 51);">    <b><span style="color: rgb(255, 0, 0);">spl_autoload_register(&quot;f1&quot;);</span></b></span></div><div><span style="color: rgb(51, 51, 51);">    $obj=new A;//本页无A类，则会自动去A.class.php中找A类。</span></div></div><div><b><span style="font-size: 19px;"><font color="#010101" face="宋体">八-9.2</font></span></b> <span style="font-size: 19px;"><font color="#010101">注册自动加载方法</font></span></div><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">在面向对象的编程风格中，我们一般会将用户自定义的自动加载函数<span style="color: rgb(255, 0, 0);"><b>封装</b></span>到一个类中！</span></font></div></div><div style="margin-left:40px;"><div align="left" style="min-height: 12pt;"><div><font color="#010101">1如果自动加载函数为<b>静态</b>方法</font></div></div></div><div style="margin-left:40px;"><div align="left" style="min-height: 12pt;"><div style="margin-left:40px;"><font color="#010101">语法形式1为spl_autoload_register(array(类名，方法名))<b>spl_autoload_register(array('Common','hhh'));</b></font></div></div></div><div style="margin-left:40px;"><div align="left" style="min-height: 12pt;"><div style="margin-left:40px;"><font color="#010101">语法形式2为spl_autoload_register('类名::方法名')</font><font color="#010101"><b>spl_autoload_register('Common::hhh');</b></font></div></div></div><div style="margin-left:40px;"><div align="left" style="min-height: 12pt;"><div><font color="#010101">2如果自动加载函数为<b>非静态</b>方法</font></div></div></div><div align="left" style="min-height: 12pt;"><div style="margin-left:80px;"><font color="#010101">先实例化对象，再注册。语法形式为spl_autoload_register(array(对象,'方法名'))</font></div><div style="margin-left:80px;"><b><span style="color: rgb(1, 1, 1);">$stu=new Common;</span> <span style="color: rgb(1, 1, 1);">        spl_autoload_register(array($stu,'hhh'));</span></b></div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>     class Common{</div><div>        //public static function hhh($class_name){          </div><div>        public function hhh($class_name){</div><div>            if (is_file(&quot;./$class_name.class.php&quot;)) {</div><div>                include_once(&quot;./$class_name.class.php&quot;);</div><div>            }else{</div><div>                die(&quot;./$class_name.class.php不存在&quot;);</div><div>            }</div><div>        }</div><div>     }</div><div>    // spl_autoload_register(array('Common','hhh')); //静态方法注册</div><div>        $stu=new Common;    //1实例化方法对象并注册该方法</div><div>        spl_autoload_register(array($stu,'hhh'));//非静态方法注册</div><div>          $obj = new A;     //2自动去A.class.php中找A类，这样就可以使用A类中的函数了。</div></div><div><b><span style="color: rgb(1, 1, 1);"><br/></span></b></div></div></span>
</div></body></html> 