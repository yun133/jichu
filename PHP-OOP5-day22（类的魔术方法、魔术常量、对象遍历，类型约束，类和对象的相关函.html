<html>
<head>
  <title>PHP-OOP5-day22（类的魔术方法、魔术常量、对象遍历，类型约束，类和对象的相关函数 ，命名空间）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303788 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1783"/>
<h1>PHP-OOP5-day22（类的魔术方法、魔术常量、对象遍历，类型约束，类和对象的相关函数 ，命名空间）</h1>

<div>
<span><div><b><span style="font-size: 21px;">PHP-OOP5-day22</span>（类的魔术方法、魔术常量、对象遍历，类型约束，<span style="color: rgb(1, 1, 1);">类和对象的相关函数</span> ，命名空间）</b></div><div align="justify"><b><font color="#010101" face="黑体" size="4"><span style="font-size:16pt"><b>一、魔术方法：</b></span></font></b>名字由系统定义，而方法体由用户自己编写的方法！</div><div style="margin-left:40px;">最大特点是：不需要用户手动调用，而是当特定的情况发生时，系统自动调用相关的魔术方法！</div><div style="margin-left:40px;"><b>注意：</b>__autoload不算是魔术方法，但是其语法形式很类似于魔术方法！</div><div align="justify" style="font-weight: bold; font-size: 20px;margin-left:40px;"><font color="#010101" face="黑体" size="4"><span style="font-size:16pt"><b>类的魔术方法</b></span></font></div><div align="justify" style="min-height: 12pt;margin-left:40px;"><div><span style="font-size: 12px;"><b><font color="#010101">__construct(),</font><font color="#010101">__destruct(),</font><font color="#010101">__clone(),</font><font color="#010101">__get(),</font><font color="#010101">__set(),</font><font color="#010101">__unset(),</font><font color="#010101">__isset(),</font><font color="#010101">__call(),</font><font color="#010101">__callstatic(),</font><font color="#010101">__sleep(),</font><font color="#010101">__wakeup()</font></b></span></div></div><div align="justify" style="font-weight: bold; font-size: 15px;margin-left:40px;"><font color="#010101" face="Calibri" size="4"><span style="font-size:14pt"><b>__invoke()</b></span></font></div><div align="justify" style="min-height: 13pt;margin-left:40px;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">当我们把对象当做一个函数（或方法）来调用的时候，会自动执行该魔术方法</span></font></div><div align="justify" style="min-height: 14pt;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">之所以可以使用匿名函数</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt; background:#ffff00">$func</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">闭包对象成功地调用函数，就是因为闭包对象里面有一个</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt; background:#ffff00">__invoke</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">魔术方法</span></font></div></div></div><div align="justify" style="font-weight: bold; font-size: 15px;margin-left:40px;"><font color="#010101" face="Calibri" size="4"><span style="font-size:14pt"><b>__toString()</b></span></font></div><div align="justify"><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">当我们把一个对象当成是一个字符串来使用的时候，会自动的执行该模仿方法！</span></font></div><div style="margin-left:40px;"><span style="color: rgb(1, 1, 1);"><span style="font-family: 宋体;">public function __toString(){ return serialize($this);}//</span></span><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">返回值可以是该对象序列化成字符串的结果！</span></font></div></div></div><div align="justify" style="min-height: 13pt;"><div><span style="font-size: 19px;"><b><font color="#010101">二、类的魔术常量</font></b></span></div><div style="margin-left:40px;"><span style="font-size: 16px;"><b><span style="color: rgb(1, 1, 1);">__LINE__</span></b></span> <span style="color: rgb(51, 51, 51); font-style: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255); float: none; display: inline !important;">文件中的当前行号</span></div><div align="left" style="min-height: 10pt;margin-left:40px;"><div><font color="#010101" size="1"><span style="font-size:9pt">__TRAIT__trait的名称，trait是PHP实现代码复用的一种方法，类似于接口。（5.4开始支持）</span></font></div></div></div><div align="justify" style="margin-left:40px;"><span style="font-size: 16px;"><b><font color="#010101"><b>__CLASS__：</b></font></b></span><font color="#010101" size="2"><span style="font-size:10pt">代表的是当前的类名！</span></font></div><div align="justify" style="margin-left:40px;"><div align="justify" style="min-height: 14pt;"><div style="margin-left:40px;"><font color="#010101" size="2"><span style="font-size:10pt; background:#ffff00">注意与</span></font><font color="#010101" size="2"><span style="font-size:10pt; background:#ffff00">self</span></font><font color="#010101" size="2"><span style="font-size:10pt; background:#ffff00">的区别：例return new __CLASS__；是错误的，无法new</span></font></div></div><div align="justify" style="min-height: 14pt;"><div style="margin-left:40px;"><font color="#010101" size="2"><span style="font-size:10pt">     self</span></font><font color="#010101" size="2"><span style="font-size:10pt">是指该类的本身（一种结构，不仅仅包括类名），而</span></font><font color="#010101" size="2"><span style="font-size:10pt">__CLASS__</span></font><font color="#010101" size="2"><span style="font-size:10pt">只是一个类名（类名只是类的一部分！）</span></font></div><div style="margin-left:40px;"><span style="color: rgb(1, 1, 1);">但是：<b>$classname=__CLASS__; return new $classname;</b>是可以new的，这里是可变类名的一种语法。</span></div></div></div><div style="margin-left:40px;"><span style="font-size: 16px;"><b><font color="#010101"><b>__METHOD__：</b></font></b></span><font color="#010101" size="2"><span style="font-size:10pt">代表当前的方法名！---</span></font><span style="color: rgb(1, 1, 1);">在类里echo __METHOD__;//结果A::showCLassName</span></div><div align="left" style="min-height: 10pt;"><div style="margin-left:40px;"><b><font color="#010101">__FILE__</font></b><font color="#010101">文件的完整路径和文件名,</font></div><div align="left" style="min-height: 10pt;"><div style="margin-left:40px;"><b><font color="#010101">__DIR__</font></b><font color="#010101">文件所在的目录</font></div><div align="left" style="min-height: 10pt;"><div style="margin-left:40px;"><b><font color="#010101">__FUNCTION__</font></b><font color="#010101">函数的名称</font></div><div align="left" style="min-height: 10pt;"><div style="margin-left:40px;"><b><font color="#010101">__NAMESPACE__</font></b><font color="#010101">当前命名空间的名称</font></div></div></div></div></div><div align="justify"><div align="justify" style="min-height: 13pt;"><div><b><span style="font-size: 19px;"><font color="#010101">三、对象的遍历</font></span></b><font color="#010101" size="2"><span style="font-size:10pt">使用</span></font><font color="#010101" size="2"><span style="font-size:10pt">foreach</span></font><font color="#010101" size="2"><span style="font-size:10pt">语句！</span></font></div></div></div><div align="justify"><div align="justify" style="min-height: 13pt;"><div><b><span style="font-size: 19px;"><font color="#010101" face="宋体">对象的自定义遍历</font></span></b></div></div></div><ol><li>对象的遍历受属性的访问控制的限制！</li><li>对象毕竟是有“生命力”的，可以自定义遍历！</li></ol><div align="justify"><div align="justify" style="min-height: 14pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">对象的自定义遍历，就是指使用</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">foreach</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">遍历某一个类的对象的时候，可以在</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">foreach</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">的各个阶段，调用相应的自定义的方法来完成！</span></font></div><div align="justify" style="min-height: 14pt;margin-left:40px;"><div><font color="#010101" face="����" size="1"><span style="font-size:9pt">对象的自定义遍历，需要用到接口化编程</span></font> <font color="#010101" face="宋体" size="2"><span style="font-size:10pt">，实现了一个名叫</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">Iterator</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">的系统预定义接口，那么我们在使用</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">foreach</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">遍历该类的对象的时候，就可以在</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">foreach</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">的各个阶段，调用相应的</span><span style="font-size:10pt; background:#ffff00">自定义的方法</span><span style="font-size:10pt">来实现！</span></font></div></div><div align="left" style="min-height: 10pt;"><div style="margin-left:40px;"><font color="#010101" face="����" size="1"><span style="font-size:9pt">Iterator里面有五个抽象方法：1</span></font><font color="#010101" face="����" size="1"><span style="font-size:9pt">current — 返回当前元素，2</span></font><font color="#010101" face="����" size="1"><span style="font-size:9pt">key — 返回当前元素的键，3</span></font><font color="#010101" face="����" size="1"><span style="font-size:9pt">next — 向前移动到下一个元素</span></font></div><div style="margin-left:40px;"><span style="font-size: 9pt;"><span style="font-family: ����;"><span style="color: rgb(1, 1, 1);">4</span></span></span><font color="#010101" face="����" size="1"><span style="font-size:9pt">rewind — 返回到迭代器的第一个元素，5</span></font><font color="#010101" face="����" size="1"><span style="font-size:9pt">valid — 检查当前位置是否有效</span></font></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    header('Content-type:text/html;charset=utf-8'); //对象的自定义遍历</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    class Person implements Iterator{</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        private $position = 0;</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public $a;</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public $e = array(1,2,3,4,5);</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        // 返回到迭代器的第一个元素</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public function rewind(){</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            $this-&gt;position = 0;</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        }</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        // 判断是否有效</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public function valid(){</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            return isset($this-&gt;e[$this-&gt;position]);</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        }</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        // 返回值</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public function current(){</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            return $this-&gt;e[$this-&gt;position];</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        }</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        // 返回键</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public function key(){</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            return $this-&gt;position;</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        }</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        // 指针下移</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public function next(){</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            $this-&gt;position++;</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        }</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    }</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    $obj = new Person;</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    foreach($obj as $k=&gt;$v){</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        echo $k,'=&gt;',$v,'&lt;br /&gt;';</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    }//0=&gt;1,1=&gt;2...4=&gt;5</span></span></div></div></div><div align="justify" style="min-height: 13pt;"><div><span style="font-size: 19px;"><b><font color="#010101">四、类型约束</font></b></span></div></div><div style="margin-left:40px;"><span style="font-size: 16px;"><b>数组类型约束</b></span></div><div style="margin-left:40px;">就是强制的要求函数或者方法的形参是一个数组！---数组类型约束  （array 参数）</div><div style="margin-left:40px;"><span style="font-size: 16px;"><b>对象类型约束</b></span></div><div style="margin-left:40px;">就是强制要求函数的实参必须是某一个类的对象！---对象类型约束 （类名 参数）</div><div><b><span style="font-size: 19px;"><span style="color: rgb(1, 1, 1);">五、类和对象的相关函数</span></span></b></div><div style="margin-left:40px;"><b><font color="#010101" face="Arial" size="4"><b><span style="font-size: 16pt;">class_exists()---例：</span>var_dump(class_exists('A'));//bool(true)</b></font></b><font color="#010101" face="����" size="1"><span style="font-size:9pt">检查类A是否已定义</span></font></div><div align="justify" style="margin-left:40px;"><span style="font-size: 20px;"><b><font color="#010101" face="Arial" size="4"><span style="font-size:16pt"><b>interface_exists()</b></span></font></b></span><font color="#010101" face="Arial" size="4"><b><span style="font-size: 16pt;">---例：</span>var_dump(interface_exists('I_test'));//bool(true)</b></font></div><div align="justify" style="margin-left:40px;"><span style="font-size: 20px;"><b><font color="#010101" face="Arial" size="4"><span style="font-size:16pt"><b>method_exists()</b></span></font></b></span><font color="#010101" face="Arial" size="4"><b><span style="font-size: 16pt;">---</span>例：$obj=new A;var_dump(method_exists($obj,'f1'));//bool(true)</b></font></div></div></div><div align="justify" style="margin-left:40px;"><div align="justify" style="min-height: 13pt;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">两个参数：</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">第一个参数是对象变量,</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">第二个参数是方法的名字</span></font></div></div></div><div style="margin-left:40px;"><span style="font-size: 20px;"><b><font color="#010101" face="Arial" size="4"><span style="font-size:16pt"><b>get_class():</b></span></font></b></span><font color="#010101" face="宋体">获得一个对象所属的类名！---</font><b><font color="#010101" face="Arial"><b>参数</b></font></b><b><font color="#010101" face="Arial"><b>一个对象</b></font></b></div><div align="justify" style="margin-left:40px;"><span style="font-size: 20px;"><b><font color="#010101" face="Arial" size="4"><span style="font-size:16pt"><b>get_parent_class()</b></span></font></b></span><font color="#010101" face="宋体">获得对象或类的父类！</font><font color="#010101" face="宋体">---</font><b><font color="#010101" face="Arial"><b>参数</b></font></b><b><font color="#010101" face="Arial"><b>一个对象</b></font></b></div><div style="margin-left:40px;"><b><font color="#010101" face="Arial" size="4"><span style="font-size:16pt"><b>get_class_methods()</b></span></font></b><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">作用就是返回该类的方法！</span></font><font color="#010101" face="宋体">---</font><b><font color="#010101" face="Arial"><b>参数是</b></font></b><b><font color="#010101" face="Arial"><b>一个类，</b></font></b><b><span style="font-family: Arial;"><span style="color: rgb(1, 1, 1);">返回的是一个数组。</span></span></b></div><div style="margin-left:40px;"><div align="left" style="min-height: 10pt;"><div><font color="#010101" face="����" size="1"><span style="font-size:9pt">注意：在类外只能打印出公共方法，在类内可以打印出所有方法。</span></font></div></div></div><div align="justify" style="min-height: 13pt;margin-left:40px;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">公开的静态方法和公开的非静态方法都可以被返回，但是无法返回受保护的和私有的方法名（在类外执行的时候）！</span></font></div></div><div align="justify" style="margin-left:40px;"><span style="font-size: 20px;"><b><font color="#010101" face="Arial" size="4"><span style="font-size:16pt"><b>get_class_vars()</b></span></font></b></span><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">函数的参数也只有一个，也是类名,</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">能返回公开的属性！</span></font></div><div align="justify" style="font-size: 20px;margin-left:40px;"><b><font color="#010101" face="Arial" size="4"><span style="font-size:16pt"><b>is_object()</b></span></font></b><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">判断一个变量是否为一个对象！</span></font></div><div align="justify"><div align="justify" style="min-height: 13pt;"><div><span style="font-size: 19px;"><b><font color="#010101">六、命名空间概述</font></b></span></div><div align="justify" style="min-height: 13pt;"><div><font color="#010101">一种用来将内存逻辑划分的功能，用来区分同名的类，函数和常量</font></div></div></div></div><div align="justify"><div align="justify" style="min-height: 13pt;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">1、基本语法：</span></font><b><font color="#FF0000"><span style="font-size:12pt">namespace</span></font> <font color="#FF0000"><span style="font-size:12pt">空间名字</span></font><font color="#FF0000"><span style="font-size:12pt">;</span></font></b></div></div><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">其中，空间的名字尊重基本标识符的命名规则（以字母、数字和下划线构成，不能以数字开头）</span></font></div></div></div><div align="justify"><div align="justify" style="min-height: 13pt;"><div><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>几点需要特别注意的地方：</b></span></font></div></div></div><div align="justify"><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">1如果一个脚本的开始需要定义命名空间，则必须在<b>脚本</b>的<b>最开始处</b>定义！（<b>例&lt;?php ?&gt;标签前不能有空格</b>）</span></font></div><div align="justify" style="min-height: 14pt;"><div style="margin-left:40px;"><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">2</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">一个脚本周期内，可以定义多个命名空间，并且不同的空间内可以定义相同名称的函数、常量和类！</span></font></div></div></div></div><div align="justify"><div align="justify" style="min-height: 13pt;"><div><span style="font-size: 16px;"><b><font color="#010101" face="宋体">2、空间成员</font></b></span></div><div align="justify" style="min-height: 14pt;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">一个命名空间的内部可以有任意的</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">PHP</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">代码，但</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">命名空间本身<span style="color: rgb(255, 0, 0);">只“管辖”三种</span>空间成员：</span><span style="font-size:10pt; background:#ffff00">常量、函数和类</span><span style="font-size:10pt">，其他的都不属于空间成员！</span></font><span style="font-family: 宋体;"><span style="color: rgb(1, 1, 1);">例：</span></span><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">变量不属于空间成员！</span></font></div><div align="justify"><span style="font-size: 16px;"><b><font color="#010101" face="黑体"><b>注意：</b></font></b></span><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">命名空间内部除了空间成员（类、常量和函数）受限制之外，其他的代码都是该怎么执行就怎么执行，不存在任意的区别！</span></font></div></div></div></div><div align="justify" style="font-weight: bold;"><div><span style="font-size: 16px;"><font color="#010101" face="宋体"><b>3、子空间</b></font></span></div></div><div align="justify"><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">同计算机的目录可以存在子目录一样，内存中的空间可以存在子空间！</span></font></div></div><div align="justify" style="min-height: 14pt;margin-left:40px;"><div><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>目录：</b></span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">A/B/C</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">，其中，</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">C</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">就是</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">B</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">目录的子目录，而</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">B</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">又是</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">A</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">的子目录</span></font></div></div><div align="justify" style="min-height: 14pt;margin-left:40px;"><div><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>空间：</b></span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">namespace A\B\C;</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">其中空间</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">C</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">就是空间</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">B</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">的子空间，而空间</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">B</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">又是空间</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">A</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">的子空间（<b>注意使用反斜杠</b></span></font><b><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">\</span></font></b><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">），</span></font></div><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">     其表示的含义是创建了一个名字为</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">C</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">的子空间！并且</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">A</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">空间和</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">B</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">空间也一起创建了！</span></font></div></div></div><div align="left" style="min-height: 10pt;"><div style="margin-left:40px;"><font color="#010101">注意：子空间不能直接访问父空间的内容。因为它们只是逻辑上的划分。</font></div></div><div align="justify" style="font-weight: bold;"><span style="font-size: 19px;"><font color="#010101" face="宋体"><b>4、空间成员的访问：注意使用\反斜杆</b></font></span></div><div align="justify"><div align="justify" style="min-height: 14pt;"><div style="margin-left:40px;"><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">PHP</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">提供了三种访问空间成员的方法：</span><span style="font-size:10pt; background:#ffff00">非限定名称方法、限定名称访问和完全限定名称访问！</span></font></div></div></div><div style="margin-left:40px;"><div><span style="font-size: 16px;"><b>1非限定名称访问</b></span></div></div><div align="justify" style="margin-left:40px;"><div align="justify" style="min-height: 13pt;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">所谓的非限定名称访问，就是指在访问空间成员的时候，<b>没有指定具体的空间的名字</b>，我们前面的访问方式都是属于非限定名称访问！</span></font></div></div></div><div style="margin-left:40px;"><div><span style="font-size: 16px;"><b><font color="#010101" face="黑体"><b>2限定名称访问</b></font></b></span></div></div><div align="justify" style="margin-left:40px;"><div align="justify" style="min-height: 13pt;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">就是从当前空间开始，访问其子空间的成员！</span></font></div></div></div><div align="justify" style="margin-left:40px;"><div align="justify" style="min-height: 14pt;"><div><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>语法形式：</b></span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">子空间名</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt; background:#ffff00">\</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">空间成员名-----例：namespace A\B; C\getName();</span></font></div></div></div><div style="margin-left:40px;"><div><span style="font-size: 16px;"><b><font color="#010101" face="黑体"><b>3完全限定名称访问</b></font></b></span></div></div><div align="justify"><div align="justify" style="min-height: 13pt;margin-left:40px;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">就是直接从根空间（类比网站根目录）开始绝对路径访问,</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">优势就是，可以在任意的空间访问其他任意空间的成员！</span></font></div></div><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>语法形式：</b></span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt; background:#ffff00">\</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">空间</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt; background:#ffff00">1\</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">空间</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt; background:#ffff00">2\</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">……</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt; background:#ffff00">\</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">空间成员，其中第一个</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt; background:#ffff00">\</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">代表的是根空间！---例;</span></font><font size="2"><span style="font-size:10pt; background:#ffff00"><span style="color: rgb(1, 1, 1);"><span style="font-family: 宋体;">namespace A\B</span></span>\C;</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">\A\B\sayHi();</span></font></div></div></div><div><span style="font-size: 16px;"><b><font color="#010101" face="宋体"><b>5、空间引入</b></font></b></span></div><div align="justify"><div align="justify" style="min-height: 13pt;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">当一个脚本包含了另一个脚本的时候，就出现空间引入！</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">也就是在一个脚本中引入了另外一个脚本的命名空间！</span></font></div><div><img src="PHP-OOP5-day22（类的魔术方法、魔术常量、对象遍历，类型约束，类和对象的相关函_files/Image.png" type="image/png" style="height: auto;"/></div><div align="justify" style="min-height: 14pt;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">那么问题来了，如何访问空间</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt; background:#ffff00">Second</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">里面的成员呢？</span></font><div align="justify" style="min-height: 13pt;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">只能采用完全限定名称访问</span></font></div><div><img src="PHP-OOP5-day22（类的魔术方法、魔术常量、对象遍历，类型约束，类和对象的相关函_files/Image [1].png" type="image/png" style="height: auto;"/></div></div></div></div></div></div><div><b><span style="font-size: 16px;"><font color="#010101" face="宋体"><b>6空间类的引入</b></font></span></b><span style="font-family: 宋体;"><span style="background-color: rgb(255, 255, 0);"><span style="color: rgb(1, 1, 1);">注意：include和空间类引入都不能少，否则找不到进不到对应空间。</span></span></span></div><div align="justify"><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">所谓的空间类的引入就是指把其他空间的类引入到当前的空间，在当前自己的空间就可以使用这个类了！</span></font></div><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>方案一：通过完全限定名称访问</b></span></font></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    namespace Second;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    $stu=new \First\Student;</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    var_dump($stu);</span></span></span></div></div></div><div align="justify" style="min-height: 14pt;"><div style="margin-left:40px;"><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>方案二：把</b></span></font><font color="#FF0000" face="Calibri" size="2"><span style="font-size:10pt"><b>First</b></span></font><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>空间的类引入到自己的空间（</b></span></font><font color="#FF0000" face="Calibri" size="2"><span style="font-size:10pt"><b>Second</b></span></font><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>空间）</b></span></font></div></div><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>语法如下：</b></span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt"><b>use</b></span></font> <font color="#010101" face="宋体" size="2"><span style="font-size:10pt"><b>空间名</b></span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt"><b>\</b></span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt"><b>类名</b></span></font></div></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">//如果被引入的类的名字和当前空间原有的类的名字相同，就会出现冲突,通过起个别名解决。</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    use \First\Student</span> <span style="color: rgb(255, 0, 0);">as</span> <span style="color: rgb(51, 51, 51);">PHPstudent;//将First下面的Student类引入到当前的空间</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    $stu=new PHPstudent;//起了别名后直接使用别名</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    var_dump($stu);</span></span></span></div></div><div><b><span style="font-size: 16px;"><font color="#010101" face="宋体"><b>7、全局空间</b></font></span></b></div><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">如果不给脚本定义命名空间，那么脚本中所有的内容（类、常量和函数）就都属于全局空间！</span></font></div></div><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">直接使用根空间访问全局空间的成员即可：</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">语法为：</span></font> <font color="#010101" face="Calibri" size="2"><span style="font-size:10pt; background:#ffff00">\</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">全局空间成员</span></font></div></div></div></div></span>
</div></body></html> 