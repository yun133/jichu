<html>
<head>
  <title>PHP-OOP3-day20（继承、封装、多态，重写、final、abstract、interface ）</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/303788 (zh-CN, DDL); Windows/6.1.7601 Service Pack 1 (Win64);"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1775"/>
<h1>PHP-OOP3-day20（继承、封装、多态，重写、final、abstract、interface ）</h1>

<div>
<span><div><b><span style="font-size: 21px;">PHP-OOP3-day20<span style="font-size: 16px;">（继承、封装、多态，重写、final、</span></span></b><span style="font-size: 19px;"><b>abstract、interface</b></span> <b><span style="font-size: 21px;"><span style="font-size: 16px;">）</span></span></b></div><div align="justify" style="min-height: 13pt;"><div><span style="font-size: 19px;"><b><font color="#010101" face="宋体">一、类的继承</font></b></span><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">面向对象的三大特性之一：继承性！</span></font><font color="#010101" face="����" size="1"><span style="font-size:9pt">利于代码的扩展和重用</span></font></div></div><div align="justify" style="min-height: 13pt;"><div align="justify" style="min-height: 16pt;"><div style="margin-left:40px;"><font color="#FF0000" face="宋体"><span style="font-size:12pt"><b>伟大的程序员都懒！都要在两个字上下功夫：</b></span></font><font color="#FF0000" face="Calibri"><span style="font-size:12pt"><b>”</b></span></font><font color="#FF0000" face="宋体"><span style="font-size:12pt"><b>简</b></span></font><font color="#FF0000" face="Calibri"><span style="font-size:12pt"><b>”</b></span></font><font color="#FF0000" face="宋体"><span style="font-size:12pt"><b>，</b></span></font><font color="#FF0000" face="Calibri"><span style="font-size:12pt"><b>”</b></span></font><font color="#FF0000" face="宋体"><span style="font-size:12pt"><b>易</b></span></font><font color="#FF0000" face="Calibri"><span style="font-size:12pt"><b>”</b></span></font><font color="#FF0000" face="宋体"><span style="font-size:12pt"><b>！</b></span></font></div></div></div><div align="justify" style="min-height: 13pt;margin-left:40px;"><div><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>继承：</b></span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">一个类从另外一个已有的类获得其成员特性，就叫作继承！extends</span></font></div></div><div align="justify" style="min-height: 13pt;margin-left:40px;"><div><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>几个概念：派生，</b></span></font><span style="font-family: 宋体;"><span style="color: rgb(1, 1, 1);">父类（基类）parent、子类（派生类）、扩展、单继承、继承链条</span></span></div></div><div align="justify" style="min-height: 14pt;"><div style="margin-left:40px;"><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>单继承：</b></span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">在</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">PHP</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">中，一个类只能继承自一个其他的类，不同同时继承多个类，单继承也是大多数面向对象语言的特性（</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">C++</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">支持多继承）</span></font></div><div align="justify" style="font-weight: bold; font-size: 20px;"><div><font color="#010101" face="黑体" size="4"><b>几点强调</b></font></div></div><ol><li style="display:inline;list-style:none;"><ol><li>属性和方法都可以被继承</li><li>继承的本质，不是把父类中的代码复制到子类的内部，而是通过<span style="color: rgb(255, 0, 0);">继承链条</span>，找到相应的成员！</li></ol></li></ol><div style="box-sizing: border-box; padding: 8px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="margin-left:40px;">    class Goods{//定义一个父类Goods</div><div style="margin-left:40px;">        public $goods_id;</div><div style="margin-left:40px;">        public $goods_name;</div><div style="margin-left:40px;">        public $goods_price;</div><div style="margin-left:40px;">        public function showName(){</div><div style="margin-left:40px;">                    echo $this-&gt;goods_name;</div><div style="margin-left:40px;">                }</div><div style="margin-left:40px;">    }</div><div style="margin-left:40px;">    class Book extends Goods{</div><div style="margin-left:40px;">        public $publisher;</div><div style="margin-left:40px;">        public $author;</div><div style="margin-left:40px;">    }</div><div style="margin-left:40px;">    class Mango extends Book{//继承链条</div><div style="margin-left:40px;">        public $system;</div><div style="margin-left:40px;">        public $pages;   </div><div style="margin-left:40px;">    }</div><div style="margin-left:40px;">    $book=new Book;</div><div style="margin-left:40px;">    $mango=new Mango;</div><div style="margin-left:40px;">    echo &quot;&lt;pre&gt;&quot;;</div><div style="margin-left:40px;">    var_dump($book,$mango);</div><div style="margin-left:40px;">    $book-&gt;goods_name=&quot;海贼王&quot;;</div><div style="margin-left:40px;">    $book-&gt;showName();//输出：海贼王</div></div></div><div align="justify" style="min-height: 14pt;"><div><b><span style="font-size: 19px;"><font color="#010101" face="宋体">二、2.1多态</font></span></b></div><div align="left" style="min-height: 10pt;"><div style="margin-left:40px;"><font color="#010101" face="����" size="1"><span style="font-size:9pt">1、多态，从字面意思上理解，就是多种状态。</span></font></div></div><div align="left" style="min-height: 10pt;margin-left:40px;"><div><font color="#010101" face="����" size="1"><span style="font-size:9pt">2、在面向对面语言中，多态指的是不同的对象，对同一个消息的不同响应。</span></font></div></div><div align="left" style="min-height: 10pt;margin-left:40px;"><div><font color="#010101" face="����" size="1"><span style="font-size:9pt">3、多态，意味着一个对象有着多重特征，可以在特定的情况下，表现不同的状态，从而对应着不同的属性和方法。</span></font></div></div><div align="left" style="min-height: 10pt;"><div style="margin-left:40px;"><font color="#010101" face="����" size="1"><span style="font-size:9pt">4、有继承才有多态。方法的重写可以实现多态。因此父类尽量是抽象类或者接口。</span></font></div><div style="box-sizing: border-box; padding: 8px; font-size: 12px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">class Bird{// 定义一个Bird类</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public $age;// Bird的年龄</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public $sex;// Bird的性别</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public function chirm(){// 鸟鸣方法</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            echo &quot;叽叽喳喳...&lt;br /&gt;&quot;;</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        }</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public function fly(){</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            echo &quot;飞呀飞呀...&lt;br /&gt;&quot;;</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        }</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">}   </span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">class Parrot extends Bird{// 鹦鹉类 重写了chirm鸟鸣方法</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public function chirm(){</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            echo &quot;你好你好...&lt;br /&gt;&quot;;</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        }</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">}   </span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">class Ostrich extends Bird{// 鸵鸟类 重写了fly方法</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public function fly(){</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            $this-&gt;run();</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        }</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public function run(){</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            echo &quot;跑啊跑啊...&lt;br /&gt;&quot;;</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        }</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">}   </span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    function fly($obj){// 如果属于鸟类，则让它飞行</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        if($obj instanceof Bird) $obj-&gt;fly();</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    }</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    function chirm($obj){// 如果属于鸟类，则让它鸣叫</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        if($obj instanceof Bird) $obj-&gt;chirm();</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    }</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    //    不同的对象对同一种方法的不同反应</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    fly(new Ostrich());    //跑啊跑啊...</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    fly(new Parrot());    //飞呀飞呀...</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    chirm(new Ostrich());//叽叽喳喳...</span></span></div><div><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    chirm(new Parrot());//你好你好...</span></span></div></div></div><div><b><span style="font-size: 19px;"><font color="#010101" face="宋体">  2.2重写</font><font color="#010101" face="Calibri">override</font></span></b></div></div><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">1、重写也叫作覆盖，就是当子类的成员与父类的成员的名字相同的时候，从父类继承下来的成员会重新定义！</span></font></div><div style="margin-left:40px;">注意：<font color="#010101" face="����" size="1"><span style="font-size:9pt">重写是由继承链决定的，当子类调用一个方法的时候。如果在子类没有找到，就会接着在父类寻找。所以重写并不是真正意义上的覆盖父类方法。</span></font></div></div><div align="justify" style="min-height: 13pt;margin-left:40px;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">在真实的项目中，一般是可以通过修改方法的名字来避免重写的！</span></font></div></div><div align="justify" style="min-height: 13pt;margin-left:40px;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">但是，有些方法的名字是固定的，比如：构造方法，析构方法等魔术方法，所以，这种情况，重写不可避免！</span></font></div></div><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">2、重写的其他语法</span></font></div><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">1.如果必须要执行被重写的父类方法，必须<span style="color: rgb(255, 0, 0);">在子类的方法中</span>，显式的调用父类的同名方法！此时子类方法<span style="color: rgb(255, 0, 0);">参数要加上它。</span></span></font></div><div style="margin-left:40px;"><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>     语法-----父类名</b></span></font><font color="#FF0000" face="Calibri" size="2"><span style="font-size:10pt"><b>::</b></span></font><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>父类中的方法名-----例：Goods::_contruct($name);</b></span></font></div></div><div align="justify" style="min-height: 14pt;margin-left:40px;"><div><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt; background:#ffff00">2.parent</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">不一定就代表本类的上一级父类，如果父类中没有找到相应的方法，会继续的向更上一级的父类查找！</span></font></div><div><font color="#FF0000" size="2"><span style="font-size:10pt"><b>          parent::_contruct($name);---建议使用parent代替</b></span></font></div></div><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">3.当子类重写父类的方法的时候，方法的参数形式（个数），必须与父类保持一致（构造方法除外）</span></font></div><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">     例：$mango=new Mango(&quot;尾田&quot;,&quot;海贼王&quot;);</span></font></div></div><div align="justify" style="min-height: 13pt;"><div><span style="font-size: 19px;"><b><font color="#010101" face="宋体">三、3.1封装</font></b></span><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">面向对象的三大特性之一：</span></font><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>封装性</b></span></font><font color="#010101" face="����" size="1"><span style="font-size:9pt">主要是为了实现程序的<b><span style="color: rgb(255, 0, 0);">单入口</span></b>。</span></font></div><div><span style="font-size: 19px;"><b><font color="#010101" face="宋体">    3.2访问控制修饰符</font></b></span></div></div><div align="justify" style="min-height: 14pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">1、在</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt; background:#ffff00">PHP</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">中，一共有三个访问控制范围的概念：</span></font></div></div><div align="justify" style="min-height: 13pt;margin-left:40px;"><div><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>当前类内：</b></span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">当前代码所在的类内</span></font></div></div><div align="justify" style="min-height: 13pt;margin-left:40px;"><div><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>继承链类内：</b></span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">所有在一个继承链上的类内，并且对于链上的任意的一个类，访问的范围是一样</span></font></div></div><div align="justify" style="min-height: 13pt;margin-left:40px;"><div><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>类外：</b></span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">除了类内，都是类外</span></font></div><div align="justify" style="min-height: 13pt;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">所以，访问控制修饰符也一共有三个：</span></font></div></div></div><div align="justify" style="min-height: 14pt;margin-left:40px;"><div><font color="#FF0000" face="Calibri" size="2"><span style="font-size:10pt"><b>public</b></span></font><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>：</b></span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">公共的，当前类内，继承链类内和类外都可以被访问到</span></font></div></div><div align="justify" style="min-height: 14pt;margin-left:40px;"><div><font color="#FF0000" face="Calibri" size="2"><span style="font-size:10pt"><b>protected</b></span></font><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>：</b></span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">受保护的，当前类内以及继承链上的类内可以被访问到（该类或其子类）</span></font></div></div><div align="justify" style="min-height: 14pt;margin-left:40px;"><div><font color="#FF0000" face="Calibri" size="2"><span style="font-size:10pt"><b>private</b></span></font><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>：</b></span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">私有的，只有当前类内可以被访问到</span></font></div></div><div align="justify" style="min-height: 13pt;margin-left:40px;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">2、访问控制修饰符的使用原则</span></font></div></div><div align="justify" style="min-height: 13pt;"><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">尽量的隐藏类的内部实现，仅仅公开一些操作接口！（接口就是对象对外部公开的操作方法）</span></font></div></div></div><div style="margin-left:40px;"><b>其他原则</b></div><div style="margin-left:40px;">1.当子类重写父类的成员时，子类成员的访问控制权限不应该低于父类的访问控制权限！</div><div style="margin-left:40px;">     若父类：public   子类：只能是public，若父类：protected 子类：可以是protected也可以是pubic</div><div style="margin-left:40px;"><b>2.</b>从形式上看，子类可以继承父类的私有成员，但是却无法使用！</div><div align="justify" style="min-height: 14pt;margin-left:40px;"><div><font color="#010101">3</font><font color="#010101">.私有成员（私有属性和私有方法）都不能被重写，但是子类还是可以定义跟父类私有成员同名的成员，但是此时，只是当作子类自身的新的成员而已！</font></div></div><div align="justify" style="min-height: 14pt;"><div style="margin-left:40px;"><font color="#010101">4</font><font color="#010101">，虽然父类的私有方法不能被重写，但是，如果子类重新定义了一个同名的方法的时候，方法<span style="color: rgb(255, 0, 0);">参数</span>的形式（参数的个数）还是<span style="color: rgb(255, 0, 0);">需</span>要和父类保持<span style="color: rgb(255, 0, 0);">一致</span>！</font></div><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    class Student{</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">        private $stu_age;</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">        private $stu_name;</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">        public function set_age($age){</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">            if (is_int($age)&amp;&amp;$age&gt;=0 &amp;&amp;$age&lt;=150) {</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                $this-&gt;stu_age=$age;</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">            } else {</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                echo &quot;非法的年龄信息&quot;;</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">                return false;</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">            }</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><br/></span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">        }</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    }</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    $stu=new Student;</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    $stu-&gt;set_age(10.5);//调用类中公开的接口</span></span></span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    //echo</span></span></span> <span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">$stu-&gt;</span></span></span> <span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">stu_age;//报错！</span></span></span> <b style="color: rgb(0, 0, 0); font-family: &quot;Microsoft YaHei&quot;; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial;">Fatal error</b><span style="color: rgb(0, 0, 0); font-family: &quot;Microsoft YaHei&quot;; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; display: inline !important; float: none;">: Cannot access private property Student::$stu_age，改为public则可以访问</span></div><div><span style="color: rgb(51, 51, 51);"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;">    var_dump($stu);//非法的年龄信息……     //<span style="color: rgb(255, 0, 0);">可以有效控制用户的行为--封装优点</span></span></span></span></div><div><span style="color: rgb(0, 0, 0); font-family: &quot;Microsoft YaHei&quot;; font-size: medium; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: normal; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-style: initial; text-decoration-color: initial; display: inline !important; float: none;">//当set_age()10;时object(Student)#1 (2) { [&quot;stu_age&quot;:&quot;Student&quot;:private]=&gt; int(10) [&quot;stu_name&quot;:&quot;Student&quot;:private]=&gt; NULL }，可以看到但类外不能访问</span></div></div></div><div align="justify" style="min-height: 14pt;"><div><span style="font-size: 19px;"><b><font color="#010101" face="宋体">四、提高</font><font color="#010101" face="Calibri">MySQLDB</font><font color="#010101" face="宋体">类的封装性</font></b></span></div></div><div style="margin-left:40px;"><b>私有化属性，</b><b>私有化方法</b></div><div align="justify" style="min-height: 14pt;margin-left:40px;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">给</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt; background:#ffff00">MySQLDB</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">类增加三个公开的方法：</span></font></div></div><div align="justify" style="min-height: 14pt;margin-left:40px;"><div><font color="#FF0000" face="Calibri" size="2"><span style="font-size:10pt"><b>fetchAll</b></span></font><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>：</b></span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">得到所有的记录（比较适合查询结果是多行多列的情况）</span></font></div></div><div align="justify" style="min-height: 14pt;margin-left:40px;"><div><font color="#FF0000" face="Calibri" size="2"><span style="font-size:10pt"><b>fetchRow</b></span></font><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>：</b></span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">得到一条记录（比较适合查询结果是单行的结果集）</span></font></div></div><div align="justify" style="min-height: 14pt;"><div style="margin-left:40px;"><font color="#FF0000" face="Calibri" size="2"><span style="font-size:10pt"><b>fetchColumn</b></span></font><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>：</b></span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">得到一条记录的第一个字段（比较适合查询结果是单行单列的结果集）</span></font></div></div><div align="justify" style="min-height: 14pt;"><div><b><span style="font-size: 19px;"><font color="#010101">五、final</font><font color="#010101">最终类</font></span></b></div></div><div align="justify" style="min-height: 14pt;"><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">类有两个“极端”：</span></font></div></div><div align="justify" style="min-height: 14pt;"><div style="margin-left:40px;"><font color="#FF0000" face="Calibri" size="2"><span style="font-size:10pt"><b>final</b></span></font><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>类：</b></span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">也叫作最终类，不能被继承，只能实例化对象</span></font></div><div align="justify" style="min-height: 14pt;"><div style="margin-left:40px;"><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">final</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">最终类其实就是实际开发过程中的一种语法上的<span style="color: rgb(255, 0, 0);">规范</span>！</span></font></div><div style="margin-left:40px;"><b><span style="font-size: 20px;"><b>最终方法</b><b>final method</b></span></b></div><div style="margin-left:40px;"><div align="left" style="min-height: 10pt;"><div><font color="#010101" face="����" size="1"><span style="font-size:9pt">当一个类还需要继承，但是不希望该类中的某些方法被重写，可以使用最终方法。</span></font></div></div></div><div align="justify"><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">当该类被其他的类所继承的时候，该最终方法不能被重写！</span></font></div></div></div></div></div><div align="justify" style="min-height: 14pt;"><div><span style="font-size: 19px;"><b>六、abstract</b><b>类：</b><span style="font-size: 16px;"><font color="#010101">抽象类，不能实例化对象，只能被继承</font></span></span></div></div></div><div align="justify" style="min-height: 13pt;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">     抽象类其实就是不完整的类，所以无法实例化一个真实的对象！</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">需要下一级的类去</span><span style="font-size:10pt; background:#ffff00">实现</span><span style="font-size:10pt">（完善方法体）！</span></font></div></div><div align="justify" style="min-height: 13pt;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">     而继承它的类也只有两种选择：1</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">要么完成父类（抽象类）中的抽象方法（完善方法体）2</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">要么继续做抽象类！</span></font></div></div><div align="justify" style="min-height: 13pt;"><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    abstract class Animal{</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public function move(){</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        }</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    }</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    class Bird extends Animal{   </span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public function move(){</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            echo &quot;I can fly!&lt;br/&gt;&quot;;</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        }</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    }</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    class Snake extends Animal{   </span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public function move(){</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">            echo &quot;I can creep!&lt;br/&gt;&quot;;</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        }</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    }</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    $bird=new Bird;</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    $bird-&gt;move();//I can fly!</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    $snake=new Snake;</span></span></span></div><div style="margin-left:40px;"><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    $snake-&gt;move();//I can creep!</span></span></span></div></div></div><div><span style="color: rgb(1, 1, 1);"><span style="font-family: 黑体;"><span style="font-size: 16px;"><b>特别强调</b></span></span></span></div><ol><li>如果一个类继承自一个抽象类，而其自身不是一个抽象类，则必须实现父类中的所有的抽象方法！</li><li>抽象类中，不但可以包括抽象方法，还可以包括其他任意的普通成员（属性、常量、非抽象方法），都可以被子类所继承</li></ol><div><b><span style="font-size: 16px;"><span style="font-family: 黑体;"><span style="color: rgb(1, 1, 1);"><b>抽象类的作用</b></span></span></span></b></div><ol><li>可以完成普通类的继承，为其他的类提供公共的代码！</li><li>抽象类往往用于规定子类中必须要完成的方法或者成员，规定子类的方法结构，有时候为了保证完成一系列功能相似的多种操作类的结构一致，我们要求这些类都继承自一个相同的抽象类！</li></ol><div align="justify" style="min-height: 14pt;"><div><span style="font-size: 19px;"><b><font color="#010101" face="Calibri">七、interface</font><font color="#010101" face="宋体">接口</font></b></span></div></div><div align="justify" style="min-height: 14pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">在</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt">PHP</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">中定义一个<span style="color: rgb(255, 0, 0);"><b>接口</b></span>，其实就是一种<b><span style="color: rgb(255, 0, 0);">纯粹的规范或规定</span></b>，规定该接口的下级类必须要</span><span style="font-size:10pt; background:#ffff00">“实现”</span><span style="font-size:10pt">的公共方法！</span></font></div></div><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">接口不是类！接口是类的规范，类又是对象的规范！</span></font></div></div><div align="justify" style="min-height: 13pt;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt; background:#ffff00">在一个接口中，<span style="color: rgb(255, 0, 0);">只能</span>出现<span style="color: rgb(255, 0, 0);">两种成员</span>：</span></font></div></div><div align="justify" style="min-height: 13pt;"><div style="margin-left:40px;"><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>接口常量，</b></span></font><font color="#FF0000" face="宋体" size="2"><span style="font-size:10pt"><b>抽象方法：</b></span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">没有方法体的方法，但是此时，</span><span style="font-size:10pt; background:#ffff00">抽象方法中<span style="color: rgb(255, 0, 0);">所有</span>方法必须声明为</span></font><span style="color: rgb(255, 0, 0);"><font face="Calibri" size="2"><span style="font-size:10pt; background:#ffff00">public</span></font></span><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">（与抽象类中的抽象方法不同）</span></font></div></div><div align="justify" style="min-height: 14pt;"><div><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">     要使接口作用到类上，就必须使用</span></font><font color="#010101" face="Calibri" size="2"><span style="font-size:10pt; background:#ffff00">implements</span></font><font color="#010101" face="宋体" size="2"><span style="font-size:10pt">关键字，意思为“实现”，其实和继承的本质是一样的！</span></font></div></div><div><b>当一个类“实现”一个接口的时候，也只有两种选择：</b></div><ol><li>实现该接口中所有的公开的抽象方法（完善方法体）</li><li>如果该类没有实现接口中的部分（或全部）公开的抽象方法，就应该把该类声明成抽象类，然后等待更下一级的类去实现！此时，没有被实现的方法最好继续声明成抽象方法！</li></ol><div style="box-sizing: border-box; padding: 8px; border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902);"><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    interface I_animal{</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public function move();</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public function eat();</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    }</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    interface I_shengwu{</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public function sleep();</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    }</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    abstract class Human implements <b>I_animal,I_shengwu</b>{//</span></span></span><span style="color: rgb(255, 0, 0);"><font face="����" size="1"><span style="font-size:9pt">接口支持多实现。这也是接口和抽象方法的本质区别。</span></font></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public function move(){}</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        public function eat(){}</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">        abstract public function sleep();</span></span></span></div><div><span style="font-size: 12px;"><span style="font-family: Monaco, Menlo, Consolas, 'Courier New', monospace;"><span style="color: rgb(51, 51, 51);">    }</span></span></span></div></div><div align="justify" style="font-weight: bold; font-size: 20px;"><font color="#010101" face="黑体" size="4"><span style="font-size:16pt"><b>接口与抽象类的比较</b></span></font></div><ol><li>接口不是类(需要用interface来进行声明,需要其他类用implements实现 )，但抽象类是类(需要class进行声明，需要用extends继承 )</li><li>从逻辑或结构上看，接口可以看成是抽象类的一个“子集”，比抽象类更“抽象”，<span style="color: rgb(255, 0, 0);">只有抽象方法和常量</span>没有其他的普通的方法</li><li><div align="left" style="min-height: 10pt;"><font color="#010101" face="����" size="1"><span style="font-size:9pt">类只支持单继承，而接口支持多实现。这也是接口和抽象方法的本质区别。</span></font></div></li></ol><div>     4.接口与抽象类都可以作为其他类的规范，都可以规定下级类的内部结构，但是在真实的项目中，接口使用的要多一些！</div><div style="-en-codeblock: true; box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.14902); background-position: initial initial; background-repeat: initial initial;"><div>    interface I_USB{</div><div>        const WIDTH=10;</div><div>        const HEIGHT=4;</div><div>        public function load();</div><div>        public function run();</div><div>    }</div><div>    class MOuse implements I_USB{</div><div>        public function load(){</div><div>            echo &quot;加载鼠标驱动&lt;br/&gt;&quot;;</div><div>        }</div><div>        public function run(){</div><div>            echo &quot;鼠标运行&lt;br/&gt;&quot;;</div><div>        }</div><div>    }</div><div>    class Disk implements I_USB{</div><div>        public function load(){</div><div>            echo &quot;加载移动硬盘驱动&lt;br/&gt;&quot;;</div><div>        }</div><div>        public function run(){</div><div>            echo &quot;移动硬盘运行&lt;br/&gt;&quot;;</div><div>        }</div><div>    }</div><div>    $mouse=new MOuse;</div><div>    $mouse-&gt;run();//鼠标运行</div></div><div><br/></div></span>
</div></body></html> 